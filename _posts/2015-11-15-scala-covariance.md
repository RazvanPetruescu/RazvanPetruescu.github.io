---
layout: post
title:  "On Types and Type Systems with Scala: Variance (part II)"
date:   2015-11-15 00:00:00
excerpt: "A glimpse into Covariance"
tags: [type system, scala, functional, covariance]
categories: [programming, types]
comments: true
---

> Introduction

In the [first part]({% post_url 2015-11-01-scala-types-invariance %}) of the
series, I started by examining the concept of variance and introduced invariance.

This article describes another form of variance, namely, covariance.

> Example

Nothing serves the presentation of new concepts better than examples, therefore
I will continue with a concrete scenario.

Imagine an event-driven software system. Such a system is based on broad
categories of events, like events related to the functioning of the system
(system events), events generated by user actions (user events) and so on.

An initial attempt to model these events in Scala :

{% highlight scala %}

trait Event

trait UserEvent extends Event

trait SystemEvent extends Event

trait ApplicationEvent extends SystemEvent

trait ErrorEvent extends ApplicationEvent

{% endhighlight %}

As stated [earlier]({% post_url 2015-11-01-scala-types-invariance %}), traits in
Scala are a way to define types.

Since there can be many categories of events it would make sense to create
separate event sources for each type. An event source will inherit from a generic
trait, `Source`, that is parameterized. Also, design decisions have led to making
the type parameter covariant. A covariant type parameter is created by marking the
parametrized type with `+`.

{% highlight scala %}

trait Source[+Out] {
  def get(): Out
}

{% endhighlight %}

Some concrete event sources :

{% highlight scala %}

trait UserEventSource extends Source[UserEvent]

val ues = new UserEventSource {
  override def get(): UserEvent = ???
}

trait SystemEventSource extends Source[SystemEvent]

val syes = new SystemEventSource {
  override def get(): SystemEvent = ???
}

{% endhighlight %}

In reality there should be more event sources in the system. In this fictional
example, an `UserEventSource` and a `SystemEventSource` are all that is needed.
Note also that actual implementations are omitted (by using the `???` symbol).

At some point, our requirements dictate that we need to intercept and forward
events to another parts of our system, which are interested in those events (in
order to log them, or use them for other purposes).

So a method is written to handle this scenario.

{% highlight scala %}

def forwardEventsComingFrom(source: Source[Event]): Unit = {
  // imagine events are continuously intercepted as they arrive
  source.get()
  // and then forwarded
}

{% endhighlight %}

This method is declared to accept a source of `Event`s as a parameter.
The designer of this method has taken advantage of the fact that `Source` is
declared to be covariant, therefore the following calls are legal :

{% highlight scala %}

forwardEventsComingFrom(ues)

forwardEventsComingFrom(syes)

{% endhighlight %}

> Covariance explained

Note that both `UserEventSource` and `SystemEventSource` can be passed as
parameters to the method.

How is this possible?

Covariance refers to the possibility to substitute a type parameter with its
subtype. Accordingly, covariance can be depicted as a 'narrowing' relationship.

By relaxing the [invariance]({% post_url 2015-11-01-scala-types-invariance %})
constraint, both `Source[UserEvent] (UserEventSource)` and `Source[SystemEvent]
(SystemEventSource)` become equivalent to `Source[Event]` and thus accepted by
the compiler.

A more formal definition would be that, for any types `T`, `A` and `B` if `T[B]`
conforms (or is assignable) to `T[A]` then `B` is a sub-type of `A`.

Another way to visualize this relationship is that the direction of conformance
(or assignment) is the same as the inheritance arrow, as depicted in the
following picture.

![](/images/scala-invariance-covariance-pic.png)

Therefore, the following statement would compile:
`val v: Source[Event] = new UserEventSource()`

In case of inheritance, covariance allows subclasses to override and use
narrower (or more specific) types than their superclass in covariant positions
as the return value.

> Closing remarks

This article explained and demonstrated covariance via a practical example. The
next part will discuss contravariance, and introduce a new concept, type bounds.
